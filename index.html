<html>
    <head>
        <meta name='viewport' content='width=device-width'/>
        <link rel="stylesheet" href="ui.css">
        <link rel="stylesheet" href="selector.css">
        <title>Pixel Renderer</title>
        <style>
            body {margin: 0;}
            canvas {width: 100%; height: 100%};
            #header{background-color: #2E2E2E; width: 100%; height: 100%}
        </style>
    </head>

    <body>
        <div id="main" class="parent">

            <div id="header" class="header">
                <p class="header-logo">Pixel Renderer</p>
                <input type="file" name="loader" id="loader" class="header-content"onchange="changeCubeColor()"/>
            </div>
            
            <div id="selector" class="selector">
                <div id="info">
                    <button type="button" id="add_char_btn" class="add-character-btn"><b>+</b> Add New Character</button>
                    <div id="character-list" >
                    <char-element></char-element>
                    </div>
                </div>
            </div>

            <div id="material" class=material></div>

            <div id="preview" class=preview>,
                <div class="slidecontainer">
                    <input type="range" min="0.1" max="1" step="0.01" value="1" class="slider" id="slider" onchange="">
                </div>
                <script src="three/three.js"></script>
                <script src="dependencies/loaders/FBXLoader.js"></script>
                <script src="dependencies/libs/inflate.min.js"></script>
                <script id="xesq" class=preview>

                    container = document.getElementById("preview")
                    var scene = new THREE.Scene();
                    //scene.background = new THREE.Color(0xf5f5f5);
                    
                    scr_x_size = (window.innerWidth-(window.innerWidth*0.45)-12);
                    scr_y_size = (window.innerHeight-(window.innerHeight*0.07));
                    var aspect = scr_x_size/scr_y_size;
                    var frustum_size = 1200;
                    
                    var ratio = 1;
                    var slider = document.getElementById("slider");
                    slider.addEventListener("input", function(){ratio=slider.value; slider.change()});
                    window.addEventListener( 'resize', onWindowResize, false );

                    //container.appendChild(renderer.domElement);

                    //var camera = new THREE.OrthographicCamera(aspect*frustum_size/-2, aspect*frustum_size/2, frustum_size/2, frustum_size/-2, 0.1, 100);
                    
                    //var container;
                    var camera, scene, renderer, light;
                    var clock = new THREE.Clock();
                    var mixer;
                    init();
                    animate();
                    function init() {
                        //document.body.appendChild( container );
                        camera = new THREE.PerspectiveCamera( 105, aspect, 0.1, 20000 );
                        camera = new THREE.OrthographicCamera(aspect*frustum_size/-2, aspect*frustum_size/2, frustum_size/2, frustum_size/-2, 0.1, 500);
                        camera.position.x += 300;
                        camera.position.z += 100;
                        //var helper = new THREE.CameraHelper(cam2);
                        //camera.position.set( 900, 700, 1000 );
                        scene = new THREE.Scene();
                        scene.background = new THREE.Color( 0xf5f5f5 );
                        scene.background = new THREE.Color( 0xff0000 );

                        light = new THREE.DirectionalLight( 0xffffff );
                        
                        //scene.add( helper );
                        scene.add( light );

                        // ground
                        // var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
                        // mesh.rotation.x = - Math.PI / 2;
                        // mesh.receiveShadow = false;
                        // scene.add( mesh );
                        // var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
                        // grid.material.opacity = 0.2;
                        // grid.material.transparent = true;
                        // scene.add( grid );

                        // model
                        this.obj = null;
                        
                        var loader = new THREE.FBXLoader();

                        function load_init( object ) {
                            mixer = new THREE.AnimationMixer( object );

                            object.traverse( function ( child ) {
                                if ( child.isMesh ) {
                                    //console.log(child)

                                    //console.log(child.material.length)

                                    const oldMat = child.material;
                                    var newMat = new THREE.MeshBasicMaterial();

                                    if(oldMat.length == undefined)
                                    {
                                        console.log(newMat.copy(oldMat));

                                        child.material = newMat;

                                        child.material = new THREE.MeshBasicMaterial( {  
                                        color: oldMat.color,
                                        } );
                                    }
                                    else
                                    {
                                        for(var i = 0; i < oldMat.length; i++)
                                        {
                                            child.material[i] = new THREE.MeshBasicMaterial( {  
                                            color: oldMat[i].color,
                                            } );
                                        }
                                    }

                                    console.log("Finished Iteration")
                                }
                            } );
                            
                            object.position.z -= 200;
                            object.position.y -= 250;
                            console.log("left traverse");
                            var action = mixer.clipAction( object.animations[ 0 ] );
                            action.play();
                            scene.add( object );
                        } 

                        var true_load = load_init.bind(this);
                        loader.load( 'Anims/Capoeira.fbx', true_load);
                        console.log(scene.children);
                        console.log(scene.children.length);
                        console.log(scene.children[scene.children.length-1]);
                        //for(var i = 0; i < scene.le)
                        
                        //console.log(obj);
                        renderer = new THREE.WebGLRenderer( { antialias: false } );
                        renderer.setSize( window.innerWidth, window.innerHeight );
                        //renderer.shadowMap.enabled = true;
                        container.appendChild( renderer.domElement );
                        window.addEventListener( 'resize', onWindowResize, false );
                    }


                    function onWindowResize() {
                        scr_x_size = (window.innerWidth-(window.innerWidth*0.45)-12);
                        scr_y_size = (window.innerHeight-(window.innerHeight*0.07));
                        var aspect = scr_x_size/scr_y_size;
                        //camera.aspect = aspect;
                        camera.updateProjectionMatrix();
                        renderer.setSize( scr_x_size, scr_y_size );
                    }


                    function animate() {
                        requestAnimationFrame( animate );
                        var delta = clock.getDelta();
                        if ( mixer ) mixer.update( delta );
                        renderer.setPixelRatio(ratio);
                        renderer.render( scene, camera );
                    }

                </script>
            </div>
            
        </div>

        <script src="Character/InputNode.js"></script>
        <script src="Character/CharacterElement.js"></script>
        <script src="Character/CharacterList.js"></script>
        <script src="Character/AnimList.js"></script>
            
    </body>
</html>